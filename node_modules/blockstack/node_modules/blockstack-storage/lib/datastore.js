'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.datastoreGetId = datastoreGetId;
exports.sanitizePath = sanitizePath;
exports.dirname = dirname;
exports.basename = basename;
exports.datastoreCreateRequest = datastoreCreateRequest;
exports.datastoreCreate = datastoreCreate;
exports.datastoreDeleteRequest = datastoreDeleteRequest;
exports.datastoreDelete = datastoreDelete;
exports.datastoreMount = datastoreMount;
exports.datastoreMountOrCreate = datastoreMountOrCreate;
exports.lookup = lookup;
exports.listdir = listdir;
exports.stat = stat;
exports.getFile = getFile;
exports.putFile = putFile;
exports.mkdir = mkdir;
exports.deleteFile = deleteFile;
exports.rmdir = rmdir;

var _schemas = require('./schemas');

var _inode = require('./inode');

var _util = require('./util');

var http = require('http');
var uuid4 = require('uuid/v4');
var bitcoinjs = require('bitcoinjs-lib');
var BigInteger = require('bigi');
var Promise = require('promise');
var assert = require('assert');
var Ajv = require('ajv');
var jsontokens = require('jsontokens');

var EPERM = 1;
var ENOENT = 2;
var EACCES = 13;
var EEXIST = 17;
var ENOTDIR = 20;
var EINVAL = 22;
var EREMOTEIO = 121;

var LOCAL_STORAGE_ID = "blockstack";
var SUPPORTED_STORAGE_CLASSES = ["read_public", "write_public", "read_private", "write_private", "read_local", "write_local"];
var REPLICATION_STRATEGY_CLASSES = {
   'local': new Set(['read_local', 'write_local']),
   'publish': new Set(['read_public', 'write_private']),
   'public': new Set(['read_public', 'write_public']),
   'private': new Set(['read_private', 'write_private'])
};

/*
 * Helper method to validate a JSON response
 * against a schema.  Returns the validated object
 * on success, and throw an exception on error.
 */
function validateJSONResponse(resp, result_schema) {

   var ajv = new Ajv();
   if (result_schema) {
      try {
         var valid = ajv.validate(result_schema, resp);
         assert(valid);
         return resp;
      } catch (e) {
         try {
            // error message
            var _valid = ajv.validate(_schemas.CORE_ERROR_SCHEMA, resp);
            assert(_valid);
            return resp;
         } catch (e2) {
            console.log("Failed to validate with desired schema");
            console.log(e.stack);
            console.log("Failed to validate with error schema");
            console.log(e2.stack);
            console.log("Desired schema:");
            console.log(result_schema);
            console.log("Parsed message:");
            console.log(resp);
            throw new Error("Invalid core message");
         }
      }
   } else {
      return resp;
   }
}

/*
 * Helper method to issue an HTTP request.
 * @param options (Object) set of HTTP request options
 * @param result_schema (Object) JSON schema of the expected result
 *
 * Returns a structured JSON response on success, conformant to the result_schema.
 * Returns plaintext on success if the content-type is application/octet-stream
 * Returns a structured {'error': ...} object on client-side error
 * Throws on server-side error
 */
function httpRequest(options, result_schema, body) {

   if (body) {
      options['body'] = body;
   }

   var url = 'http://' + options.host + ':' + options.port + options.path;
   return fetch(url, options).then(function (response) {

      if (response.status >= 500) {
         throw new Error(response.statusText);
      }

      if (response.status === 404) {
         return { 'error': 'No such file or directory', 'errno': ENOENT };
      }

      if (response.status === 403) {
         return { 'error': 'Access denied', 'errno': EACCES };
      }

      if (response.status === 401) {
         return { 'error': 'Invalid request', 'errno': EINVAL };
      }

      if (response.status === 400) {
         return { 'error': 'Operation not permitted', 'errno': EPERM };
      }

      var resp = null;
      if (response.headers.get('content-type') === 'application/json') {
         return response.json().then(function (resp) {
            return validateJSONResponse(resp, result_schema);
         });
      } else {
         return response.text();
      }
   });
}

/*
 * Convert a datastore public key to its ID.
 * @param ds_public_key (String) hex-encoded ECDSA public key
 */
function datastoreGetId(ds_public_key_hex) {
   var ec = bitcoinjs.ECPair.fromPublicKeyBuffer(Buffer.from(ds_public_key_hex, 'hex'));
   return ec.getAddress();
}

/*
 * Get a *uncompressed* public key (hex) from private key
 */
function getPubkeyHex(privkey_hex) {
   var privkey = BigInteger.fromBuffer((0, _inode.decodePrivateKey)(privkey_hex));
   var public_key = new bitcoinjs.ECPair(privkey);

   public_key.compressed = false;
   var public_key_str = public_key.getPublicKeyBuffer().toString('hex');
   return public_key_str;
}

/*
 * Get query string device list from datastore context
 */
function getDeviceList(datastore_ctx) {
   var escaped_device_ids = [];
   var _iteratorNormalCompletion = true;
   var _didIteratorError = false;
   var _iteratorError = undefined;

   try {
      for (var _iterator = datastore_ctx.app_public_keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
         var dk = _step.value;

         escaped_device_ids.push(escape(dk.device_id));
      }
   } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
         }
      } finally {
         if (_didIteratorError) {
            throw _iteratorError;
         }
      }
   }

   var res = escaped_device_ids.join(',');
   return res;
}

/*
 * Get query string public key list from datastore context
 */
function getPublicKeyList(datastore_ctx) {
   var escaped_public_keys = [];
   var _iteratorNormalCompletion2 = true;
   var _didIteratorError2 = false;
   var _iteratorError2 = undefined;

   try {
      for (var _iterator2 = datastore_ctx.app_public_keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
         var dk = _step2.value;

         escaped_public_keys.push(escape(dk.public_key));
      }
   } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
         }
      } finally {
         if (_didIteratorError2) {
            throw _iteratorError2;
         }
      }
   }

   var res = escaped_public_keys.join(',');
   return res;
}

/*
 * Sanitize a path.  Consolidate // to /, and resolve foo/../bar to bar
 * @param path (String) the path
 *
 * Returns the sanitized path.
 */
function sanitizePath(path) {

   var parts = path.split('/').filter(function (x) {
      return x.length > 0;
   });
   var retparts = [];

   for (var i = 0; i < parts.length; i++) {
      if (parts[i] === '..') {
         retparts.pop();
      } else {
         retparts.push(parts[i]);
      }
   }

   return '/' + retparts.join('/');
}

/*
 * Given a path, get the parent directory.
 *
 * @param path (String) the path.  Must be sanitized
 */
function dirname(path) {
   return '/' + path.split('/').slice(0, -1).join('/');
}

/*
 * Given a path, get the base name
 *
 * @param path (String) the path. Must be sanitized
 */
function basename(path) {
   return path.split('/').slice(-1)[0];
}

/*
 * Given a host:port string, split it into
 * a host and port
 *
 * @param hostport (String) the host:port
 *
 * Returns an object with:
 *      .host
 *      .port
 */
function splitHostPort(hostport) {

   var host = hostport;
   var port = 80;
   var parts = hostport.split(':');
   if (parts.length > 1) {
      host = parts[0];
      port = parts[1];
   }

   return { 'host': host, 'port': port };
}

/*
 * Create the signed request to create a datastore.
 * This information can be fed into datastoreCreate()
 * Returns an object with:
 *      .datastore_info: datastore information
 *      .datastore_sigs: signatures over the above.
 */
function datastoreCreateRequest(ds_type, ds_private_key_hex, drivers, device_id, all_device_ids) {

   assert(ds_type === 'datastore' || ds_type === 'collection');
   var root_uuid = uuid4();

   var ds_public_key = getPubkeyHex(ds_private_key_hex);
   var datastore_id = datastoreGetId(ds_public_key);
   var root_blob_info = (0, _inode.makeDirInodeBlob)(datastore_id, datastore_id, root_uuid, {}, device_id, 1);

   // actual datastore payload
   var datastore_info = {
      'type': ds_type,
      'pubkey': ds_public_key,
      'drivers': drivers,
      'device_ids': all_device_ids,
      'root_uuid': root_uuid
   };

   var data_id = datastore_id + '.datastore';
   var datastore_blob = (0, _inode.makeMutableDataInfo)(data_id, (0, _util.jsonStableSerialize)(datastore_info), device_id, 1);

   var datastore_str = (0, _util.jsonStableSerialize)(datastore_blob);

   // sign them all
   var root_sig = (0, _inode.signDataPayload)(root_blob_info.header, ds_private_key_hex);
   var datastore_sig = (0, _inode.signDataPayload)(datastore_str, ds_private_key_hex);

   // make and sign tombstones for the root
   var root_tombstones = (0, _inode.makeInodeTombstones)(datastore_id, root_uuid, all_device_ids);
   var signed_tombstones = (0, _inode.signMutableDataTombstones)(root_tombstones, ds_private_key_hex);

   var info = {
      'datastore_info': {
         'datastore_id': datastore_id,
         'datastore_blob': datastore_str,
         'root_blob_header': root_blob_info.header,
         'root_blob_idata': root_blob_info.idata
      },
      'datastore_sigs': {
         'datastore_sig': datastore_sig,
         'root_sig': root_sig
      },
      'root_tombstones': signed_tombstones
   };

   return info;
}

/*
 * Create a datastore
 * Asynchronous; returns a Promise that resolves to either {'status': true} (on success)
 * or {'error': ...} (on error)
 */
function datastoreCreate(blockstack_hostport, blockstack_session_token, datastore_request) {

   var payload = {
      'datastore_info': {
         'datastore_blob': datastore_request.datastore_info.datastore_blob,
         'root_blob_header': datastore_request.datastore_info.root_blob_header,
         'root_blob_idata': datastore_request.datastore_info.root_blob_idata
      },
      'datastore_sigs': {
         'datastore_sig': datastore_request.datastore_sigs.datastore_sig,
         'root_sig': datastore_request.datastore_sigs.root_sig
      },
      'root_tombstones': datastore_request.root_tombstones
   };

   var hostinfo = splitHostPort(blockstack_hostport);

   var options = {
      'method': 'POST',
      'host': hostinfo.host,
      'port': hostinfo.port,
      'path': '/v1/stores'
   };

   if (blockstack_session_token) {
      options['headers'] = { 'Authorization': 'bearer ' + blockstack_session_token };
   }

   var body = JSON.stringify(payload);
   options['headers']['Content-Type'] = 'application/json';
   options['headers']['Content-Length'] = body.length;

   return httpRequest(options, _schemas.SUCCESS_FAIL_SCHEMA, body);
}

/*
 * Generate the data needed to delete a datastore.
 *
 * @param ds (Object) a datastore context (will be loaded from localstorage if not given)
 *
 * Returns an object to be given to datastoreDelete()
 */
function datastoreDeleteRequest() {
   var ds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;


   if (!ds) {
      var blockchain_id = getSessionBlockchainID();
      assert(blockchain_id);

      ds = getCachedMountContext(blockchain_id);
      assert(ds);
   }

   var datastore_id = ds.datastore_id;
   var device_ids = ds.datastore.device_ids;
   var root_uuid = ds.datastore.root_uuid;
   var data_id = datastore_id + '.datastore';

   var tombstones = (0, _inode.makeMutableDataTombstones)(device_ids, data_id);
   var signed_tombstones = (0, _inode.signMutableDataTombstones)(tombstones, ds.privkey_hex);

   var root_tombstones = (0, _inode.makeInodeTombstones)(datastore_id, root_uuid, device_ids);
   var signed_root_tombstones = (0, _inode.signMutableDataTombstones)(root_tombstones, ds.privkey_hex);

   var ret = {
      'datastore_tombstones': signed_tombstones,
      'root_tombstones': signed_root_tombstones
   };

   return ret;
}

/*
 * Delete a datastore
 *
 * @param ds (Object) OPTINOAL: the datastore context (will be loaded from localStorage if not given)
 * @param ds_tombstones (Object) OPTINOAL: signed information from datastoreDeleteRequest()
 * @param root_tombstones (Object) OPTINAL: signed information from datastoreDeleteRequest()
 *
 * Asynchronous; returns a Promise that resolves to either {'status': true} on success
 * or {'error': ...} on error
 */
function datastoreDelete() {
   var ds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
   var ds_tombstones = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
   var root_tombstones = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


   if (!ds) {
      var blockchain_id = getSessionBlockchainID();
      assert(blockchain_id);

      ds = getCachedMountContext(blockchain_id);
      assert(ds);
   }

   if (!ds_tombstones || !root_tombstones) {
      var delete_info = datastoreDeleteRequest(ds);
      ds_tombstones = delete_info['datastore_tombstones'];
      root_tombstones = delete_info['root_tombstones'];
   }

   var device_list = getDeviceList(ds);
   var payload = {
      'datastore_tombstones': ds_tombstones,
      'root_tombstones': root_tombstones
   };

   var options = {
      'method': 'DELETE',
      'host': ds.host,
      'port': ds.port,
      'path': '/v1/stores?device_ids=' + device_list
   };

   if (ds.session_token) {
      options['headers'] = { 'Authorization': 'bearer ' + ds.session_token };
   }

   var body = JSON.stringify(payload);
   options['headers']['Content-Type'] = 'application/json';
   options['headers']['Content-Length'] = body.length;

   return httpRequest(options, _schemas.SUCCESS_FAIL_SCHEMA, body);
}

/*
 * Look up a datastore and establish enough contextual information to do subsequent storage operations.
 * Asynchronous; returns a Promise
 *
 * opts is an object that must contain either:
 * * appPrivateKey (string) the application private key
 * * (optional) sessionToken (string) the Core session token, OR
 * * (optional) device_id (string) the device ID
 *
 * OR:
 *
 * * blockchainID (string) the blockchain ID of the user whose datastore we're going to access
 * * appName (string) the name of the application
 *
 * TODO: support accessing datastores from other users
 *
 * Returns a Promise that resolves to a datastore connection,
 * with the following properties:
 *      .host: blockstack host
 *      .datastore: datastore object
 *
 * Returns a Promise that resolves to null, if the datastore does not exist.
 *
 * Throws an error on all other errors
 */
function datastoreMount(opts) {

   var data_privkey_hex = opts.appPrivateKey;
   var sessionToken = opts.sessionToken;

   // TODO: only support single-user datastore access
   assert(data_privkey_hex);

   var datastore_id = null;
   var device_id = null;
   var blockchain_id = null;
   var api_endpoint = null;
   var app_public_keys = null;

   if (!sessionToken) {
      // load from user data
      var userData = getUserData();

      sessionToken = userData.coreSessionToken;
      assert(sessionToken);
   }

   var session = jsontokens.decodeToken(sessionToken).payload;

   if (data_privkey_hex) {
      datastore_id = datastoreGetId(getPubkeyHex(data_privkey_hex));
   } else {
      blockchain_id = opts.blockchainID;
      var app_name = opts.appName;

      if (!blockchain_id) {
         blockchain_id = getSessionBlockchainID();
      }

      assert(blockchain_id);
      assert(app_name);

      // TODO: look up the datastore information via Core
      // TODO: blocked by Core's lack of support for token files
      // TODO: set device_id, blockchain_id, app_public_keys
   }

   if (!device_id) {
      device_id = session.device_id;
      assert(device_id);
   }

   if (!api_endpoint) {
      api_endpoint = session.api_endpoint;
      assert(api_endpoint);
   }

   if (!blockchain_id) {
      blockchain_id = getBlockchainIDFromSessionOrDefault(session);
   }

   if (!app_public_keys) {
      app_public_keys = session.app_public_keys;
      assert(app_public_keys);
   }

   var blockstack_hostport = api_endpoint.split('://').reverse()[0];
   var hostinfo = splitHostPort(blockstack_hostport);

   var ctx = {
      'host': hostinfo.host,
      'port': hostinfo.port,
      'blockchain_id': blockchain_id,
      'device_id': device_id,
      'datastore_id': datastore_id,
      'session_token': sessionToken,
      'app_public_keys': app_public_keys,
      'session': session,
      'datastore': null
   };

   if (data_privkey_hex) {
      ctx.privkey_hex = data_privkey_hex;
   }

   var options = {
      'method': 'GET',
      'host': hostinfo.host,
      'port': hostinfo.port,
      'path': '/v1/stores/' + datastore_id + '?device_ids=' + device_id + '&blockchain_id=' + blockchain_id
   };

   options['headers'] = { 'Authorization': 'bearer ' + sessionToken };

   return httpRequest(options, _schemas.DATASTORE_RESPONSE_SCHEMA).then(function (ds) {
      if (!ds || ds.error) {
         // ENOENT?
         if (!ds || ds.errno === ENOENT) {
            return null;
         } else {
            var errorMsg = ds.error || 'No response given';
            throw new Error('Failed to get datastore: ' + errorMsg);
         }
      } else {
         ctx['datastore'] = ds.datastore;

         // save
         setCachedMountContext(blockchain_id, ctx);

         // this is required for testing purposes, since the core session token will not have been set
         var _userData = getUserData();
         if (!_userData.coreSessionToken) {
            console.log("In test framework; saving session token");
            _userData.coreSessionToken = sessionToken;
            setUserData(_userData);
         }

         return ctx;
      }
   });
}

/*
 * Get local storage object for Blockstack
 * Throws on error
 */
function getUserData() {
   var userData = localStorage.getItem(LOCAL_STORAGE_ID);
   if (userData === null) {
      userData = '{}';
   }

   userData = JSON.parse(userData);
   return userData;
}

/*
 * Save local storage
 */
function setUserData(userData) {

   var u = getUserData();
   if (u.coreSessionToken && userData.coreSessionToken) {
      // only store the newer one 
      var coreSessionToken = null;
      if (u.coreSessionToken.timestamp < userData.coreSessionToken.timestamp) {
         coreSessionToken = userData.coreSessionToken;
      } else {
         coreSessionToken = u.coreSessionToken;
      }
      userData.coreSessionToken = coreSessionToken;
   }

   localStorage.setItem(LOCAL_STORAGE_ID, JSON.stringify(userData));
}

/*
 * Get a cached app-specific datastore mount context for a given blockchain ID and application
 * Return null if not found
 * Throws on error
 */
function getCachedMountContext(blockchain_id) {

   var userData = getUserData();
   if (!userData.datastore_contexts) {
      console.log("No datastore contexts defined");
      return null;
   }

   if (!userData.datastore_contexts[blockchain_id]) {
      console.log('No datastore contexts for ' + blockchain_id);
      return null;
   }

   var ctx = userData.datastore_contexts[blockchain_id];
   if (!ctx) {
      console.log('Null datastore context for ' + blockchain_id);
      return null;
   }

   return ctx;
}

/*
 * Cache a mount context for a blockchain ID
 */
function setCachedMountContext(blockchain_id, datastore_context) {

   var userData = getUserData();
   if (!userData.datastore_contexts) {
      userData.datastore_contexts = {};
   }

   userData.datastore_contexts[blockchain_id] = datastore_context;
   setUserData(userData);
}

function getBlockchainIDFromSessionOrDefault(session) {
   if (!session.blockchain_id) {
      return (0, _inode.hashRawData)(Buffer.from(session.app_user_id).toString('base64'));
   } else {
      return session.blockchain_id;
   }
}

/*
 * Get the current session's blockchain ID
 * Throw if not defined or not present.
 */
function getSessionBlockchainID() {

   var userData = getUserData();
   assert(userData);
   assert(userData.coreSessionToken);

   var session = jsontokens.decodeToken(userData.coreSessionToken).payload;

   return getBlockchainIDFromSessionOrDefault(session);
}

/*
 * Fulfill a replication strategy using the drivers available to us.
 *
 * replication_strategy (object): a dict that maps strategies (i.e. 'local', 'public', 'private') to integer counts
 * classes (object): this is session.storage.classes (i.e. the driver classification; maps a driver name to its list of classes)
 *
 * Returns the list of drivers to use.
 * Throws on error.
 */
function selectDrivers(replication_strategy, classes) {

   // select defaults from classification and replication strategy
   var driver_sets = []; // driver_sets[i] is the set of drivers that support SUPPORTED_STORAGE_CLASSES[i]
   var driver_classes = {}; // map driver name to set of classes
   var all_drivers = new Set([]); // set of all drivers available to us
   var available_drivers = []; // drivers available to us
   var selected_drivers = []; // drivers compatible with our replication strategy (return value)
   var have_drivers = false; // whether or not we selected drivers that fulfill our replication strategy

   for (var i = 0; i < SUPPORTED_STORAGE_CLASSES.length; i++) {
      var driver_set = new Set(classes[SUPPORTED_STORAGE_CLASSES[i]]);
      driver_sets.push(driver_set);

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
         for (var _iterator3 = driver_set[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var d = _step3.value;

            all_drivers.add(d);
         }
      } catch (err) {
         _didIteratorError3 = true;
         _iteratorError3 = err;
      } finally {
         try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
               _iterator3.return();
            }
         } finally {
            if (_didIteratorError3) {
               throw _iteratorError3;
            }
         }
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
         for (var _iterator4 = driver_set[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _d = _step4.value;

            console.log('Driver ' + _d + ' implementes ' + SUPPORTED_STORAGE_CLASSES[i]);
            if (driver_classes[_d]) {
               driver_classes[_d].push(SUPPORTED_STORAGE_CLASSES[i]);
            } else {
               driver_classes[_d] = [SUPPORTED_STORAGE_CLASSES[i]];
            }
         }
      } catch (err) {
         _didIteratorError4 = true;
         _iteratorError4 = err;
      } finally {
         try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
               _iterator4.return();
            }
         } finally {
            if (_didIteratorError4) {
               throw _iteratorError4;
            }
         }
      }
   }

   var concern_fulfillment = {};

   var _iteratorNormalCompletion5 = true;
   var _didIteratorError5 = false;
   var _iteratorError5 = undefined;

   try {
      for (var _iterator5 = all_drivers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
         var _d2 = _step5.value;

         var _classes = driver_classes[_d2];

         // a driver fits the replication strategy if all of its
         // classes matches at least one concern (i.e. 'local', 'public')
         var _iteratorNormalCompletion6 = true;
         var _didIteratorError6 = false;
         var _iteratorError6 = undefined;

         try {
            for (var _iterator6 = Object.keys(replication_strategy)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
               var concern = _step6.value;


               var matches = false;
               var _iteratorNormalCompletion7 = true;
               var _didIteratorError7 = false;
               var _iteratorError7 = undefined;

               try {
                  for (var _iterator7 = _classes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                     var dclass = _step7.value;

                     if (REPLICATION_STRATEGY_CLASSES[concern].has(dclass)) {
                        matches = true;
                        break;
                     }
                  }
               } catch (err) {
                  _didIteratorError7 = true;
                  _iteratorError7 = err;
               } finally {
                  try {
                     if (!_iteratorNormalCompletion7 && _iterator7.return) {
                        _iterator7.return();
                     }
                  } finally {
                     if (_didIteratorError7) {
                        throw _iteratorError7;
                     }
                  }
               }

               if (matches) {
                  console.log('Driver ' + _d2 + ' fulfills replication concern ' + concern);

                  if (concern_fulfillment[concern]) {
                     concern_fulfillment[concern] += 1;
                  } else {
                     concern_fulfillment[concern] = 1;
                  }

                  if (concern_fulfillment[concern] <= replication_strategy[concern]) {
                     console.log('Select driver ' + _d2);
                     selected_drivers.push(_d2);
                  }
               }

               // strategy fulfilled?
               var fulfilled = true;
               var _iteratorNormalCompletion8 = true;
               var _didIteratorError8 = false;
               var _iteratorError8 = undefined;

               try {
                  for (var _iterator8 = Object.keys(replication_strategy)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                     var _concern = _step8.value;

                     var count = 0;
                     if (concern_fulfillment[_concern]) {
                        count = concern_fulfillment[_concern];
                     }

                     if (count < replication_strategy[_concern]) {
                        fulfilled = false;
                        break;
                     }
                  }
               } catch (err) {
                  _didIteratorError8 = true;
                  _iteratorError8 = err;
               } finally {
                  try {
                     if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                     }
                  } finally {
                     if (_didIteratorError8) {
                        throw _iteratorError8;
                     }
                  }
               }

               if (fulfilled) {
                  have_drivers = true;
                  break;
               }
            }
         } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion6 && _iterator6.return) {
                  _iterator6.return();
               }
            } finally {
               if (_didIteratorError6) {
                  throw _iteratorError6;
               }
            }
         }

         if (have_drivers) {
            break;
         }
      }
   } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
         }
      } finally {
         if (_didIteratorError5) {
            throw _iteratorError5;
         }
      }
   }

   if (!have_drivers) {
      throw new Error("Unsatisfiable replication strategy");
   }

   return selected_drivers;
}

/*
 * Connect to or create a datastore.
 * Asynchronous, returns a Promise
 *
 * Returns a Promise that yields a datastore connection.
 * Throws on error.
 *
 */
function datastoreMountOrCreate() {
   var replication_strategy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { 'public': 1, 'local': 1 };
   var sessionToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
   var appPrivateKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;


   if (!sessionToken) {
      var userData = getUserData();

      sessionToken = userData.coreSessionToken;
      assert(sessionToken);
   }

   // decode
   var session = jsontokens.decodeToken(sessionToken).payload;
   var blockchain_id = getBlockchainIDFromSessionOrDefault(session);

   var ds = getCachedMountContext(blockchain_id);
   if (ds) {
      return new Promise(function (resolve, reject) {
         resolve(ds);
      });
   }

   // no cached datastore context.
   // go ahead and create one (need appPrivateKey)
   if (!appPrivateKey) {
      var _userData2 = getUserData();

      appPrivateKey = _userData2.appPrivateKey;
      assert(appPrivateKey);
   }

   // sanity check
   var _iteratorNormalCompletion9 = true;
   var _didIteratorError9 = false;
   var _iteratorError9 = undefined;

   try {
      for (var _iterator9 = Object.keys(replication_strategy)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
         var strategy = _step9.value;

         var supported = false;
         var _iteratorNormalCompletion10 = true;
         var _didIteratorError10 = false;
         var _iteratorError10 = undefined;

         try {
            for (var _iterator10 = Object.keys(REPLICATION_STRATEGY_CLASSES)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
               var supported_strategy = _step10.value;

               if (supported_strategy === strategy) {
                  supported = true;
                  break;
               }
            }
         } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion10 && _iterator10.return) {
                  _iterator10.return();
               }
            } finally {
               if (_didIteratorError10) {
                  throw _iteratorError10;
               }
            }
         }

         if (!supported) {
            throw new Error('Unsupported replication strategy ' + strategy);
         }
      }
   } catch (err) {
      _didIteratorError9 = true;
      _iteratorError9 = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion9 && _iterator9.return) {
            _iterator9.return();
         }
      } finally {
         if (_didIteratorError9) {
            throw _iteratorError9;
         }
      }
   }

   var drivers = null;

   // find satisfactory storage drivers
   if (Object.keys(session.storage.preferences).includes(session.app_domain)) {

      // app-specific preference
      drivers = session.storage.preferences[app_domain];
   } else {

      // select defaults given the replication strategy
      drivers = selectDrivers(replication_strategy, session.storage.classes);
   }

   var hostport = session.api_endpoint.split('://').reverse()[0];
   var appPublicKeys = session.app_public_keys;
   var deviceID = session.device_id;
   var allDeviceIDs = [];

   for (var i = 0; i < appPublicKeys.length; i++) {
      allDeviceIDs.push(appPublicKeys[i].device_id);
   }

   console.log('Will use drivers ' + drivers.join(','));
   console.log('Datastore will span devices ' + allDeviceIDs.join(','));

   var datastoreOpts = {
      'appPrivateKey': appPrivateKey,
      'sessionToken': sessionToken
   };

   return datastoreMount(datastoreOpts).then(function (datastore_ctx) {
      if (!datastore_ctx) {
         // does not exist
         console.log("Datastore does not exist; creating...");

         var info = datastoreCreateRequest('datastore', appPrivateKey, drivers, deviceID, allDeviceIDs);

         // go create it
         return datastoreCreate(hostport, sessionToken, info).then(function (res) {
            if (res.error) {
               console.log(error);
               var errorNo = res.errno || 'UNKNOWN';
               var errorMsg = res.error || 'UNKNOWN';
               throw new Error('Failed to create datastore (errno ' + errorNo + '): ' + errorMsg);
            }

            // connect to it now
            return datastoreMount(datastoreOpts);
         });
      } else if (datastore_ctx.error) {
         // some other error
         var errorMsg = datastore_ctx.error || 'UNKNOWN';
         var errorNo = datastore_ctx.errno || 'UNKNOWN';
         throw new Error('Failed to access datastore (errno ' + errorNo + '): ' + errorMsg);
      } else {
         // exists
         return datastore_ctx;
      }
   });
}

/*
 * Path lookup
 *
 * @param ds (Object) a datastore context
 * @param path (String) the path to the inode
 * @param opts (Object) optional arguments:
 *      .extended (Bool) whether or not to include the entire path's inode information
 *      .force (Bool) if True, then ignore stale inode errors.
 *      .idata (Bool) if True, then get the inode payload as well
 *      .blockchain_id (String) this is the blockchain ID of the datastore owner, if different from the session token
 *      .ds (datastore context) if given, then use this datastore mount context instead of one from localstorage
 *
 * Returns a promise that resolves to a lookup response schema (or an extended lookup response schema, if opts.extended is set)
 */
function lookup(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {
      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_list = getDeviceList(ds);
      var device_pubkeys = getPublicKeyList(ds);
      var options = {
         'method': 'GET',
         'host': ds.host,
         'port': ds.port,
         'path': '/v1/stores/' + datastore_id + '/inodes?path=' + escape(sanitizePath(path)) + '&device_ids=' + device_list + '&device_pubkeys=' + device_pubkeys + '&blockchain_id=' + ds.blockchain_id
      };

      if (!opts) {
         opts = {};
      }

      var schema = _schemas.DATASTORE_LOOKUP_RESPONSE_SCHEMA;

      if (opts.extended) {
         options['path'] += '&extended=1';
         schema = _schemas.DATASTORE_LOOKUP_EXTENDED_RESPONSE_SCHEMA;
      }

      if (opts.force) {
         options['path'] += '&force=1';
      }

      if (opts.idata) {
         options['idata'] += '&idata=1';
      }

      return httpRequest(options, schema).then(function (lookup_response) {
         if (lookup_response.error || lookup_response.errno) {
            var errorMsg = lookup_response.error || 'UNKNOWN';
            var errorNo = lookup_response.errno || 'UNKNOWN';
            throw new Error('Failed to look up ' + path + ' (errno: ' + errorNo + '): ' + errorMsg);
         } else {
            return lookup_response;
         }
      });
   });
}

/*
 * List a directory.
 *
 * @param ds (Object) a datastore context
 * @param path (String) the path to the directory to list
 * @param opts (Object) optional arguments:
 *      .extended (Bool) whether or not to include the entire path's inode inforamtion
 *      .force (Bool) if True, then ignore stale inode errors.
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise that resolves to either directory idata, or an extended mutable datum response (if opts.extended is set)
 */
function listdir(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {

      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_list = getDeviceList(ds);
      var device_pubkeys = getPublicKeyList(ds);
      var options = {
         'method': 'GET',
         'host': ds.host,
         'port': ds.port,
         'path': '/v1/stores/' + datastore_id + '/directories?path=' + escape(sanitizePath(path)) + '&idata=1&device_ids=' + device_list + '&device_pubkeys=' + device_pubkeys + '&blockchain_id=' + ds.blockchain_id
      };

      var schema = _schemas.MUTABLE_DATUM_DIR_IDATA_SCHEMA;

      if (!opts) {
         opts = {};
      }

      if (opts.extended) {
         options['path'] += '&extended=1';
         schema = MUTABLE_DATUM_EXTENDED_RESPONSE_SCHEMA;
      }

      if (opts.force) {
         optsion['path'] += '&force=1';
      }

      if (ds.session_token) {
         options['headers'] = { 'Authorization': 'bearer ' + ds.session_token };
      }

      return httpRequest(options, schema).then(function (response) {
         if (response.error || response.errno) {
            var errorMsg = response.error || 'UNKNOWN';
            var errorNo = response.errno || 'UNKNOWN';
            throw new Error('Failed to listdir ' + path + ' (errno: ' + errorNo + '): ' + errorMsg);
         } else {
            return response;
         }
      });
   });
}

/*
 * Stat a file or directory (i.e. get the inode header)
 *
 * @param ds (Object) a datastore context
 * @param path (String) the path to the directory to list
 * @param opts (Object) optional arguments:
 *      .extended (Bool) whether or not to include the entire path's inode inforamtion
 *      .force (Bool) if True, then ignore stale inode errors.
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise that resolves to either an inode schema, or a mutable datum extended response schema (if opts.extended is set)
 */
function stat(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


   var ds = opts.ds;
   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {

      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_list = getDeviceList(ds);
      var device_pubkeys = getPublicKeyList(ds);
      var options = {
         'method': 'GET',
         'host': ds.host,
         'port': ds.port,
         'path': '/v1/stores/' + datastore_id + '/inodes?path=' + escape(sanitizePath(path)) + '&device_ids=' + device_list + '&device_pubkeys=' + device_pubkeys + '&blockchain_id=' + ds.blockchain_id
      };

      var schema = _schemas.MUTABLE_DATUM_INODE_SCHEMA;

      if (!opts) {
         opts = {};
      }

      if (opts.extended) {
         options['path'] += '&extended=1';
         schema = MUTABLE_DATUM_EXTENDED_RESPONSE_SCHEMA;
      }

      if (opts.force) {
         optsion['path'] += '&force=1';
      }

      if (ds.session_token) {
         options['headers'] = { 'Authorization': 'bearer ' + ds.session_token };
      }

      return httpRequest(options, schema).then(function (response) {
         if (response.error || response.errno) {
            var errorMsg = response.error || 'UNKNOWN';
            var errorNo = response.errno || 'UNKNOWN';
            throw new Error('Failed to stat ' + path + ' (errno: ' + errorNo + '): ' + errorMsg);
         } else {
            return response;
         }
      });
   });
}

/*
 * Get an undifferentiated file or directory and its data.
 * Low-level method, not meant for external consumption.
 *
 * @param ds (Object) a datastore context
 * @param path (String) the path to the directory to list
 * @param opts (Object) optional arguments:
 *      .extended (Bool) whether or not to include the entire path's inode inforamtion
 *      .force (Bool) if True, then ignore stale inode errors.
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise that resolves to an inode and its data, or an extended mutable datum response (if opts.extended is set)
 */
function getInode(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;


   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {

      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_list = getDeviceList(ds);
      var device_pubkeys = getPublicKeyList(ds);
      var options = {
         'method': 'GET',
         'host': ds.host,
         'port': ds.port,
         'path': '/v1/stores/' + datastore_id + '/inodes?path=' + escape(sanitizePath(path)) + '&idata=1&device_ids=' + device_list + '&device_pubkeys=' + device_pubkeys + '&blockchain_id=' + ds.blockchain_id
      };

      var schema = _schemas.MUTABLE_DATUM_INODE_SCHEMA;

      if (!opts) {
         opts = {};
      }

      if (opts.extended) {
         options['path'] += '&extended=1';
         schema = MUTABLE_DATUM_EXTENDED_RESPONSE_SCHEMA;
      }

      if (opts.force) {
         options['path'] += '&force=1';
      }

      if (ds.session_token) {
         options['headers'] = { 'Authorization': 'bearer ' + ds.session_token };
      }

      return httpRequest(options, schema).then(function (response) {
         if (response.error || response.errno) {
            var errorMsg = response.error || 'UNKNOWN';
            var errorNo = response.errno || 'UNKNOWN';
            throw new Error('Failed to getInode ' + path + ' (errno: ' + errorNo + '): ' + errorMsg);
         } else {
            return response;
         }
      });
   });
}

/*
 * Get a file.
 *
 * @param ds (Object) a datastore context
 * @param path (String) the path to the file to read
 * @param opts (Object) optional arguments:
 *      .extended (Bool) whether or not to include the entire path's inode inforamtion
 *      .force (Bool) if True, then ignore stale inode errors.
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise that resolves to either raw data, or an extended mutable data response schema (if opts.extended is set).
 * If the file does not exist, then the Promise resolves to null.  Any other errors result in an Error being thrown.
 */
function getFile(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {
      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_list = getDeviceList(ds);
      var device_pubkeys = getPublicKeyList(ds);
      var options = {
         'method': 'GET',
         'host': ds.host,
         'port': ds.port,
         'path': '/v1/stores/' + datastore_id + '/files?path=' + escape(sanitizePath(path)) + '&idata=1&device_ids=' + device_list + '&device_pubkeys=' + device_pubkeys + '&blockchain_id=' + ds.blockchain_id
      };

      var schema = 'bytes';

      if (!opts) {
         opts = {};
      }

      if (opts.extended) {
         options['path'] += '&extended=1';
         schema = MUTABLE_DATUM_EXTENDED_RESPONSE_SCHEMA;
      }

      if (opts.force) {
         options['path'] += '&force=1';
      }

      if (ds.session_token) {
         options['headers'] = { 'Authorization': 'bearer ' + ds.session_token };
      }

      return httpRequest(options, schema).then(function (response) {
         if (response.error || response.errno) {
            // ENOENT?
            if (response.errno === ENOENT) {
               return null;
            }

            // some other error
            var errorMsg = response.error || 'UNKNOWN';
            var errorNo = response.errno || 'UNKNOWN';
            throw new Error('Failed to getFile ' + path + ' (errno: ' + errorNo + '): ' + errorMsg);
         } else {
            return response;
         }
      });
   });
}

/*
 * Execute a datastore operation
 *
 * @param ds (Object) a datastore context
 * @param operation (String) the specific operation being carried out.
 * @param path (String) the path of the operation
 * @param inodes (Array) the list of inode headers to replicate
 * @param payloads (Array) the list of inode payloads in 1-to-1 correspondence to the headers
 * @param signatures (Array) the list of signatures over each inode header (also 1-to-1 correspondence)
 * @param tombstones (Array) the list of signed inode tombstones
 *
 * Asynchronous; returns a Promise that resolves to True if the operation succeeded
 */
function datastoreOperation(ds, operation, path, inodes, payloads, signatures, tombstones) {

   var request_path = null;
   var http_operation = null;
   var datastore_id = ds.datastore_id;
   var datastore_privkey = ds.privkey_hex;
   var device_list = getDeviceList(ds);
   var device_pubkeys = getPublicKeyList(ds);

   assert(inodes.length === payloads.length);
   assert(payloads.length === signatures.length);

   if (operation === 'mkdir') {
      request_path = '/v1/stores/' + datastore_id + '/directories?path=' + escape(sanitizePath(path)) + '&device_ids=' + device_list + '&device_pubkeys=' + device_pubkeys + '&blockchain_id=' + ds.blockchain_id;
      http_operation = 'POST';

      assert(inodes.length === 2);
   } else if (operation === 'putFile') {
      request_path = '/v1/stores/' + datastore_id + '/files?path=' + escape(sanitizePath(path)) + '&device_ids=' + device_list + '&device_pubkeys=' + device_pubkeys + '&blockchain_id=' + ds.blockchain_id;
      http_operation = 'PUT';

      assert(inodes.length === 1 || inodes.length === 2);
   } else if (operation === 'rmdir') {
      request_path = '/v1/stores/' + datastore_id + '/directories?path=' + escape(sanitizePath(path)) + '&device_pubkeys=' + device_pubkeys + '&device_ids=' + device_list + '&blockchain_id=' + ds.blockchain_id;
      http_operation = 'DELETE';

      assert(inodes.length === 1);
      assert(tombstones.length >= 1);
   } else if (operation === 'deleteFile') {
      request_path = '/v1/stores/' + datastore_id + '/files?path=' + escape(sanitizePath(path)) + '&device_pubkeys=' + device_pubkeys + '&device_ids=' + device_list + '&blockchain_id=' + ds.blockchain_id;
      http_operation = 'DELETE';

      assert(inodes.length === 1);
      assert(tombstones.length >= 1);
   } else {
      console.log('invalid operation ' + operation);
      throw new Error('Invalid operation ' + operation);
   }

   var options = {
      'method': http_operation,
      'host': ds.host,
      'port': ds.port,
      'path': request_path
   };

   if (ds.session_token) {
      options['headers'] = { 'Authorization': 'bearer ' + ds.session_token };
   }

   var datastore_str = JSON.stringify(ds.datastore);
   var datastore_sig = (0, _inode.signRawData)(datastore_str, datastore_privkey);

   var body_struct = {
      'inodes': inodes,
      'payloads': payloads,
      'signatures': signatures,
      'tombstones': tombstones,
      'datastore_str': datastore_str,
      'datastore_sig': datastore_sig
   };

   var body = JSON.stringify(body_struct);
   options['headers']['Content-Type'] = 'application/json';
   options['headers']['Content-Length'] = body.length;

   return httpRequest(options, _schemas.SUCCESS_FAIL_SCHEMA, body).then(function (response) {
      if (response.error || response.errno) {
         var errorMsg = response.error || 'UNKNOWN';
         var errorNo = response.errno || 'UNKNOWN';
         throw new Error('Failed to ' + operation + ' ' + path + ' (errno: ' + errorNo + '): ' + errorMsg);
      } else {
         return true;
      }
   });
}

/*
 * Given a path, get its parent directory
 * Make sure it's a directory.
 *
 * @param ds (Object) a datastore context
 * @param path (String) the path to the inode in question
 * @param opts (Object) lookup options
 *      .extended (Bool) whether or not to include the entire path's inode inforamtion
 *      .force (Bool) if True, then ignore stale inode errors.
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise
 */
function getParent(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

   var dirpath = dirname(path);
   return getInode(dirpath, opts).then(function (inode) {
      if (!inode) {
         return { 'error': 'Failed to get parent', 'errno': EREMOTEIO };
      }
      if (inode.type !== _schemas.MUTABLE_DATUM_DIR_TYPE) {
         return { 'error': 'Not a directory', 'errno': ENOTDIR };
      } else {
         return inode;
      }
   }, function (error_resp) {
      return { 'error': 'Failed to get inode', 'errno': EREMOTEIO };
   });
}

/*
 * Create or update a file
 *
 * @param ds (Object) a datastore context
 * @param path (String) the path to the file to create (must not exist)
 * @param file_buffer (Buffer or String) the file contents
 * @param opts (Object) lookup options
 *      .extended (Bool) whether or not to include the entire path's inode inforamtion
 *      .force (Bool) if True, then ignore stale inode errors.
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise
 */
function putFile(path, file_buffer) {
   var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {

      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_id = ds.device_id;
      var privkey_hex = ds.privkey_hex;

      path = sanitizePath(path);
      var child_name = basename(path);

      assert(typeof file_buffer === 'string' || file_buffer instanceof Buffer);

      // get parent dir
      return getParent(path, opts).then(function (parent_dir) {
         if (parent_dir.error) {
            return parent_dir;
         }

         // make the file inode information
         var file_payload = file_buffer;
         var file_hash = null;
         if (typeof file_payload !== 'string') {
            // buffer
            file_payload = file_buffer.toString('base64');
            file_hash = (0, _inode.hashDataPayload)(file_buffer.toString());
         } else {
            // string
            file_payload = Buffer.from(file_buffer).toString('base64');
            file_hash = (0, _inode.hashDataPayload)(file_buffer);
         }

         assert(file_hash);

         var inode_uuid = null;
         var new_parent_dir_inode = null;
         var child_version = null;

         // new or existing?
         if (Object.keys(parent_dir['idata']['children']).includes(child_name)) {

            // existing; no directory change
            inode_uuid = parent_dir['idata']['children'][child_name]['uuid'];
            new_parent_dir_inode = (0, _inode.inodeDirLink)(parent_dir, _schemas.MUTABLE_DATUM_FILE_TYPE, child_name, inode_uuid, true);
         } else {

            // new
            inode_uuid = uuid4();
            new_parent_dir_inode = (0, _inode.inodeDirLink)(parent_dir, _schemas.MUTABLE_DATUM_FILE_TYPE, child_name, inode_uuid, false);
         }

         var version = (0, _inode.getChildVersion)(parent_dir, child_name);
         var inode_info = (0, _inode.makeFileInodeBlob)(datastore_id, datastore_id, inode_uuid, file_hash, device_id, version);
         var inode_sig = (0, _inode.signDataPayload)(inode_info['header'], privkey_hex);

         // make the directory inode information
         var new_parent_info = (0, _inode.makeDirInodeBlob)(datastore_id, new_parent_dir_inode['owner'], new_parent_dir_inode['uuid'], new_parent_dir_inode['idata']['children'], device_id, new_parent_dir_inode['version'] + 1);
         var new_parent_sig = (0, _inode.signDataPayload)(new_parent_info['header'], privkey_hex);

         // post them
         var new_parent_info_b64 = new Buffer(new_parent_info['idata']).toString('base64');
         return datastoreOperation(ds, 'putFile', path, [inode_info['header'], new_parent_info['header']], [file_payload, new_parent_info_b64], [inode_sig, new_parent_sig], []);
      });
   });
}

/*
 * Create a directory.
 *
 * @param ds (Object) datastore context
 * @param path (String) path to the directory
 * @param opts (object) optional arguments
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise
 */
function mkdir(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {

      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_id = ds.device_id;
      var privkey_hex = ds.privkey_hex;

      path = sanitizePath(path);
      var child_name = basename(path);

      return getParent(path, opts).then(function (parent_dir) {
         if (parent_dir.error) {
            return parent_dir;
         }

         // must not exist
         if (Object.keys(parent_dir['idata']['children']).includes(child_name)) {
            return { 'error': 'File or directory exists', 'errno': EEXIST };
         }

         // make the directory inode information
         var inode_uuid = uuid4();
         var inode_info = (0, _inode.makeDirInodeBlob)(datastore_id, datastore_id, inode_uuid, {}, device_id);
         var inode_sig = (0, _inode.signDataPayload)(inode_info['header'], privkey_hex);

         // make the new parent directory information
         var new_parent_dir_inode = (0, _inode.inodeDirLink)(parent_dir, _schemas.MUTABLE_DATUM_DIR_TYPE, child_name, inode_uuid);
         var new_parent_info = (0, _inode.makeDirInodeBlob)(datastore_id, new_parent_dir_inode['owner'], new_parent_dir_inode['uuid'], new_parent_dir_inode['idata']['children'], device_id, new_parent_dir_inode['version'] + 1);
         var new_parent_sig = (0, _inode.signDataPayload)(new_parent_info['header'], privkey_hex);

         // post them
         return datastoreOperation(ds, 'mkdir', path, [inode_info['header'], new_parent_info['header']], [inode_info['idata'], new_parent_info['idata']], [inode_sig, new_parent_sig], []);
      });
   });
}

/*
 * Delete a file
 *
 * @param ds (Object) datastore context
 * @param path (String) path to the directory
 * @param opts (Object) options for this call
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise
 */
function deleteFile(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {

      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_id = ds.device_id;
      var privkey_hex = ds.privkey_hex;
      var all_device_ids = ds.datastore.device_ids;

      path = sanitizePath(path);
      var child_name = basename(path);

      return getParent(path, opts).then(function (parent_dir) {
         if (parent_dir.error) {
            return parent_dir;
         }

         // no longer exists?
         if (!Object.keys(parent_dir['idata']['children']).includes(child_name)) {
            return { 'error': 'No such file or directory', 'errno': ENOENT };
         }

         var inode_uuid = parent_dir['idata']['children'][child_name]['uuid'];

         // unlink
         var new_parent_dir_inode = (0, _inode.inodeDirUnlink)(parent_dir, child_name);
         var new_parent_info = (0, _inode.makeDirInodeBlob)(datastore_id, new_parent_dir_inode['owner'], new_parent_dir_inode['uuid'], new_parent_dir_inode['idata']['children'], device_id, new_parent_dir_inode['version'] + 1);
         var new_parent_sig = (0, _inode.signDataPayload)(new_parent_info['header'], privkey_hex);

         // make tombstones
         var tombstones = (0, _inode.makeInodeTombstones)(datastore_id, inode_uuid, all_device_ids);
         var signed_tombstones = (0, _inode.signMutableDataTombstones)(tombstones, privkey_hex);

         // post them
         return datastoreOperation(ds, 'deleteFile', path, [new_parent_info['header']], [new_parent_info['idata']], [new_parent_sig], signed_tombstones);
      });
   });
}

/*
 * Remove a directory
 *
 * @param ds (Object) datastore context
 * @param path (String) path to the directory
 * @param opts (Object) options for this call
 *      .blockchain_id (string) this is the blockchain ID of the datastore owner (if different from the session)
 *      .ds (datastore context) this is the mount context for the datastore, if different from one that we have cached
 *
 * Asynchronous; returns a Promise
 */
function rmdir(path) {
   var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


   var blockchain_id = opts.blockchain_id;

   if (!opts.blockchain_id) {
      blockchain_id = getSessionBlockchainID();
   }

   return datastoreMountOrCreate().then(function (ds) {

      assert(ds);

      var datastore_id = ds.datastore_id;
      var device_id = ds.device_id;
      var privkey_hex = ds.privkey_hex;
      var all_device_ids = ds.datastore.device_ids;

      path = sanitizePath(path);
      var child_name = basename(path);

      return getParent(path, opts).then(function (parent_dir) {
         if (parent_dir.error) {
            return parent_dir;
         }

         // no longer exists?
         if (!Object.keys(parent_dir['idata']['children']).includes(child_name)) {
            return { 'error': 'No such file or directory', 'errno': ENOENT };
         }

         var inode_uuid = parent_dir['idata']['children'][child_name]['uuid'];

         // unlink
         var new_parent_dir_inode = (0, _inode.inodeDirUnlink)(parent_dir, child_name);
         var new_parent_info = (0, _inode.makeDirInodeBlob)(datastore_id, new_parent_dir_inode['owner'], new_parent_dir_inode['uuid'], new_parent_dir_inode['idata']['children'], device_id, new_parent_dir_inode['version'] + 1);
         var new_parent_sig = (0, _inode.signDataPayload)(new_parent_info['header'], privkey_hex);

         // make tombstones
         var tombstones = (0, _inode.makeInodeTombstones)(datastore_id, inode_uuid, all_device_ids);
         var signed_tombstones = (0, _inode.signMutableDataTombstones)(tombstones, privkey_hex);

         // post them
         return datastoreOperation(ds, 'rmdir', path, [new_parent_info['header']], [new_parent_info['idata']], [new_parent_sig], signed_tombstones);
      });
   });
}